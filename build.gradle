import dsl.ProjectVersion
import dsl.ReleaseVersionTask
import dsl.IncrementMajorVersionListener

//apply plugin: 'idea'
// activates groovy code
//apply plugin: 'groovy'
apply plugin: 'java'

// add support for war, this will also bring in the java plugin
// so the above line was not needed
apply plugin: 'war'


// the the description property of Project object
description = "My Gradle Learning Project"

// $name is a project property - the current projects name
// $description was set above
println "Project: $name - $description"



// adding a custom property (versionfile) in the 'ext'ernal space
ext {
   // define a property in the external space that holds the version propertes
   versionfile = file ('version.properties')
   // source dir for gradle custom classes used here
   // srcDirName = 'src/main/groovy'
}

// declare a custom configuration named cargo.
// this syntax says...get me the configurations closure
// and to that, i'm going to add a cargo configuration
// that will not be visible outside of this project
configurations {
   cargo {  // we define a cargo configuration using a closure
      description = 'Classpath for Cargo Ant tasks.'
      // make this visible only to this project, used
      // if our project is a multi-module project
      visible = false
   }
   // we have defined a cargo configuration, now we can
   // use it
}



// the dependencies configuration. think of a project configuration
// as a grouping or a namesspace -- dependencies go in the
// dependencies configuration
dependencies {
   // define the dependencies
   //compile gradleApi()
   //compile localGroovy()
   providedCompile 'javax.servlet:servlet-api:2.5'
   runtime 'javax.servlet:jstl:1.1.2'
   compile group: 'org.apache.commons', name: 'commons-lang3', version: '3.1'
   testCompile ('junit:junit:4.8.2')

   // here we make use of the cargo configuration define in
   // the configurations configuration (see above)
   cargo 'org.codehaus.cargo:cargo-core-uberjar:1.3.1'
   cargo ('org.codehaus.cargo:cargo-ant:1.3.1') {
      // excludes do not include version since gradle does not
      // allow you to exclude a particular version

      //exclude group:'xml-apis', module:'xml-apis'
      //this will exclude all transitives,
      // if you do this, then you will need to explicitly
      // declare all the required dependencies
      transitive = false
   }
   //cargo 'xml-apis:xml-apis:2.0.2'
}



// define a method readVersion that returns ProjectVersion object
ProjectVersion readVersion () {
   logger.quiet 'Reading the version file.'
   if ( !versionfile.exists ()) {
      throw new GradleException ("Required version file doe not exist. $versionfile.canonicalPath")
   }

   Properties versionProperties = new Properties();
   versionfile.withInputStream { stream ->
      versionProperties.load(stream)
   }

   new ProjectVersion(versionProperties.major.toInteger(),
           versionProperties.minor.toInteger(),
           versionProperties.release.toBoolean())
}

// even though readVersion returns ProjectVersion object,
// gradle will use the objects toString method when assigning project.version
task loadVersion {
   project.version = readVersion()
}

// property of Project object that this script represents
// java jdk version
// sourceCompatibility = 1.7

repositories {
   // the local maven repo @ $HOME/.m2/repository
   mavenLocal()
   // maven central
   mavenCentral()
   // a company maven repo, eg
   maven {
      name 'A made up maven repository @ url'
      url = 'http://some/non/existent/maven/repo'
   }
}



// create my own custom task
task first {
   // with its own action
   doLast {
      println "first"
   }
}

// define 2 more tasks in gradle's weird syntax, but the <<
// as a representation of doLast is going away in Gradle 5
task second << { println "second" }
task third << { println "third" }

// the next few blocks show how to specify order in task execution
third.dependsOn ('printVersion')

// task printVersion now shows up in the gradle view to the right
// under 'versioning' grouping and you can double click to execute it
// Also has dependency on first and second
task printVersion (dependsOn: [second, first]){
   // these two properties of Task object will group (this task) printVersion
   // and provide a it a description.
   // both are used when running 'gradle tasks'
   // which displays the tasks this gradle file supports
   group = 'versioning'
   description = 'Prints the project version.'

   // every task has 2 built in actions doFirst and doLast
   doFirst {
      println "this is actually 2nd"
   }

   // gradle provides a default logger based on slf4j library
   doLast {
      logger.quiet "2nd last Version: $version"
   }
}
// we can add more actions to printVersion like this
// so now this is the first, and the doFirst
// defined above is 2nd
printVersion.doFirst { println "This is the new first action" }

// and this is the last, and the doLast
// above is 2nd last
printVersion << { println "Doing the new last action" }

// task that prints the date and time
task time {
   // since there is not group property set, time will fall into 'other' tasks
   doLast {
      println new Date();
   }
}

// use finalizedBy to set up such that running printVersion
// will auto trigger time, after printVersion is done
printVersion.finalizedBy time
//printVersion.dependsOn('loadVersion')

// built in version property
//version = new ProjectVersion(0, 1)

jar {
    baseName='todo-app'

    manifest {
        attributes 'Implementation-Title': baseName,
                   'Implementation-Version': version,
                   'Main-Class': 'com.gecko.Bootstrap'
    }
}


// creates the wrapper
task wrapper (type: Wrapper) {
   gradleVersion = '3.2'
}

// a custom task that makes a release version of the build
// you can do things like deploy to production server here, etc
task releaseVersion {
   group = 'versioning'
   description = 'Make a release version of the project'

   // define the input and output - these get set up during
   // configuration phase, looks like gradle keeps a copy of the
   // state in the dir $MODDIR/.gradle/$GRADLE_VERSION/
   // and these get compared between builds to see what
   // has changed
   // Inputs.property (String name, Object val) suggests
   // that a map holds the properties
   inputs.property 'release',  version.release
   outputs.file versionfile

   // can also execute a method on the outputs
   /* outputs.upToDateWhen {
      true
   } */

   doFirst {
      println "first in releaseVersions"
   }

   // actions - get done at task execution phase, only if the inputs
   // and outputs are not up to date
   doLast {
      // use the ant task to do the dirty work
      ant.propertyfile(file: versionfile) {
         entry(key: 'release', type: 'string', operation: '=', value: 'true')
      }
   }
}

// a test task - shows that dependsOn is a method that can be used
// in the task's configuration phase to config a task's dependency

// not using this, but shows how to external properties
task disable {
   doFirst {
      // this property comes from $MODDIR/gradle.properties
      println "$example_hao_property"
   }

   doLast {
      // this is set in $HOME/.gradle/gradle.properties
      println "$my_best_property"
   }
}


// create a task that uses the custom task,
// the input to the task is type
task makeReleaseVersion (type: ReleaseVersionTask) {
   // then assign the properties of the custom task
   // to the properties in the gradle file
   release = version.release
   destFile = versionfile
}

task createDistribution (type: Zip, dependsOn: makeReleaseVersion) {
   from war.outputs.files

   from (sourceSets*.allSource) {
      into 'src'
   }

   from (rootDir) {
      include versionfile.name
   }
}

// use the Copy Task to back up the release build
task backupReleaseVersion (type: Copy, dependsOn: createDistribution) {
   from ('build/distributions')
   destinationDir = new File('build/backup')

}

task incrementMajorVersion {
   group = 'versioning'
   description = 'Increments project major version'

   doLast {
      String current = version.toString()
      ++version.major
      String newVersion = version.toString()
      logger.quiet "Incrementing major project version: $current -> $newVersion"

      ant.propertyfile(file: versionfile) {
         entry(key: 'major', type: 'int', operation: '+', value: 1)
      }
   }
}

task release {
   println 'Sending to prod machine'
}

task incrementMinorVersion {
   group = 'versioning'
   description = 'Increments project minor version'


   // if you don't put into into a doFirst/doLast block, then it is configuration
   // code and will get executed in the configuration stage,
   doLast {
      String current = version.toString()
      ++version.minor

      String newVersion = version.toString()
      logger.quiet "Incrementing minor project version: $current -> $newVersion"

      ant.propertyfile(file: versionfile) {
         entry(key: 'minor', type: 'int', operation: '+', value: 1)
      }
   }
}

// an example of a life cycle event hook, this task will
// examine the build graph, and if the 'release' task is part of the
// build graph, it will set the release flag to true in the version file
gradle.taskGraph.whenReady {
   TaskExecutionGraph graph ->
      if (graph.hasTask(release)) {
         if (!version.release) {
            version.release = true
            ant.propertyfile (file: versionfile) {
               entry (key: 'release', type: 'string', operation: '=', value: 'true')
            }
         }
      }
}

// hook the taskgraph listener up
IncrementMajorVersionListener major = new IncrementMajorVersionListener()
gradle.taskGraph.addTaskExecutionGraphListener(major);

buildDir = './build'

task deployToLocalTomcat {
   // this is a broken task -- not working
   doLast {
      //get the 'cargo' configuration as a file tree
      FileTree cargoDeps = configurations.getByName('cargo').asFileTree
      ant.taskdef (resource: 'cargo.tasks', classpath: cargoDeps.asPath)

      ant.cargo (containerId: 'tomcat7x', action: 'run', output: "$buildDir/output.log") {
         configuration {
            deployable (type: 'war', file: 'todo-app-12.10.war')
         }

         zipUrlInstaller (installUrl: 'http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.32/bin/apache-tomcat-7.0.32.zip')
      }
   }
}

task printConfigurations {
   doLast {
      for(Map.Entry<String, Configuration> entry : configurations.getAsMap().entrySet() ) {
         println 'key: ' + entry.key + ', value: ' + entry.value.name
      }
   }
}

// tell compile to fail if there are jar conflicts
configurations.compile.resolutionStrategy {
   failOnVersionConflict()
}

// tell compile to fail if there are jar conflicts
// in the cargo configuration. run gradle dependencies to see
configurations.cargo.resolutionStrategy {
   failOnVersionConflict()
}


// prints the dependency where they are stored by gradle
task printDependencies {
   doLast {
      configurations.getByName('cargo').each {
         dependency ->
            println dependency.canonicalPath
      }

      println 'compiles'
      configurations.getByName('compile').each {
         dependency ->
            println dependency.canonicalPath
      }
   }
}

// non-conventional directory structure -> tell gradle via configuration
/* sourceSets {
    main {
        java {
            srcDirs = ['src']
        }
    }

    test {
        java {
            srcDirs = ['test']
        }
    }
} */